Expresion -> Termino Matematico
MasTermino -> (opTermino Termino)?
Termino -> Factor PorFactor
PorFactor -> (opFactor Factor)?
Factor -> Numero | Identificador | (Expresion)

Todo esto permitiria hacer: 
Asignacion -> Identificador = Expresion;

x26 = (345)*8-(10-4)/2;
Una forma de modificarla seria 
Scanf ("%i", &x26);

investigar estructura de datos (Arboles) en postfijo en si recorrido de un arbol 
Buscar un libro sobre estructura de datos y tratar de tirartelo en un semestre 

investigar que es parse, match y acomodar el getValor
solo si la condicion es falsa no debe de escribir en cadena pero si debe de parsear 

si es verdadero debe de parametrizar bloque de Instrucciones con el if 
en el if si la primera que se condiciona con las demas aun que todas sean verdaderas si la 
primera sea falsa todo se da falso 

parseo analisis sintaxtico 

1 Requerimiento 
2 el porcentaje reciduo de la division 

-----------------------------------------------------------------------------------------------------------
UNIDAD 2 20-09-23 
Semantico y revisar los cuales son los datos en bits 
En el scan debemos de tener cuidado ya que puede haber sido error Semantico

Nuevos requerimientos para esta UNIDAD

Requerimiento 1: Implemenar la ejecución del while 
Requerimiento 2: Implementar la ejecución del do while
Requerimiento 3: Implementar la ejecución del for 
Requerimiento 4: Marcar errores Semanticos (levantar excepciones)
Requerimiento 5: Implemenar el CAST

Es de esta semana a la otra ya que durara semana y media este proyecto

Variable.TiposDatos tipoDatoMayor // Como idea o por el tipo de la variable 

PESA MAS EL CASTEO QUE EL TIPO DE LA VARIABLE

DIVISION Y reciduo de la variable
char % 256 
int % 65526 

Correguir el Incremento
y generar un error semantico 


//While -> while(Condicion) BloqueInstrucciones | Instruccion
       private void While(bool ejecuta)
        {
            match("while");
            match("(");

            // Declaración de variables para el control del bucle
            int inicia = caracter;
            int lineaInicio = linea;
            bool condicion = false;
            float resultado = 0;
            string variable = getContenido();

            do
            {
                // Reiniciar las variables de control en cada iteración
                caracter = inicia;
                archivo.BaseStream.Seek(caracter, SeekOrigin.Begin);
                linea = lineaInicio;

                // Evaluar la condición del while
                condicion = Condicion();
                match(")");
                
                

                if (ejecuta && condicion)
                {
                    // Verificar si se ejecuta un bloque o una sola instrucción
                    if (getContenido() == "{")
                    {
                        BloqueInstrucciones(ejecuta && condicion);
                    }
                    else
                    {
                        Instruccion(ejecuta && condicion);
                    }

                    // Realizar el incremento de variables si es necesario
                    if (ejecuta && condicion)
                    {
                        archivo.DiscardBufferedData();
                        caracter = inicia - variable.Length - 1;
                        archivo.BaseStream.Seek(caracter, SeekOrigin.Begin);
                        nextToken();
                        linea = lineaInicio;
                    }
                }

                // Agregar el código de incremento al final del bucle
                if (ejecuta)
                {
                    resultado = Incremento(ejecuta, variable);
                    Modifica(variable, resultado);
                    archivo.DiscardBufferedData();
                    caracter = inicia - variable.Length - 1;
                    archivo.BaseStream.Seek(caracter, SeekOrigin.Begin);
                    nextToken();
                    linea = lineaInicio;   
                }
            } while (ejecuta);
            ejecuta = false;
        }

